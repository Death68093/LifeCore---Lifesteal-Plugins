# ===== LifeCore Credits =====
# Created by: Death68093
# Version: 1.0.0
# -- Support Us! --
# https://topeaglerservers.com/earn/lifesteal
# -- Other Notes --
# If you need help, be sure to ask in the wiki!
# ============================

on script load:
    if {server::deathcore::plugins::*} doesn't contain "LifeCore":
        add "LifeCore" to {server::deathcore::plugins::*}
    if {server::deathcore::plugins::*} doesn't contain "EasyEco":
        send "&2&lEnable EasyECO&2 by DeathCore skripts to enable economy features!"

variables:
    {lc::settings::heart_steal_chance} = 100
    {lc::settings::heart_steal_count} = 1
    {lc::settings::allow_pvp} = false
    {lc::settings::allow_clans} = true
    {lc::settings::allow_friendlyfire} = false
    {lc::settings::allow_back} = false
    {lc::settings::loss_type} = "drop" # drop or give
    {lc::settings::lose_on} = "player" # "player" (when killed by player), "any" (when killed any way)
    {lc::settings::allow_heart_loss} = true
    {lc::server::name} = "Our Lifesteal SMP"

function stripColors(string: string) :: string:
    set {_str} to {_string}
    set {_codes::*} to "&0", "&1", "&2", "&3", "&4", "&5", "&6", "&7", "&8", "&9", "&a", "&b", "&c", "&d", "&e", "&f", "&k", "&l", "&m", "&n", "&o", "&r"
    loop {_codes::*}:
        replace all loop-value in {_str} with ""
    return {_str}

function toggleVar(v: object) :: object:
    if {_v} is true:
        set {_v} to false
        return {_v}
    else:
        set {_v} to true
        return {_v}

# Main Settings
command /lc [<text>]:
    permission: lc.panel
    description: Open LifeCore's Settings
    aliases: lifesteal, lifestealcore, lifecore
    trigger:
        set {_arg_1} to arg-1
        if {_arg_1} is set:
            if {_arg_1} is "help":
                make player execute command "lchelp"
                stop
            send "&cUsage: /lc [help]"
            stop
        set {_panel} to a new chest inventory with 6 rows named "LifeCore - Home"
        set metadata value "core" of {_panel} to true
        set slot 0 of {_panel} to a barrier named "Close"
        set slot 10 of {_panel} to a nether star named "Heart Management"
        set slot 12 of {_panel} to 
        open {_panel} to player

function openCoreSettings(page: number, player: player):
    if {_page} is 0:
        make {_player} execute command "lc"
    else if {_page} is 1:
        set {_page} to a new chest inventory with 6 rows named "LifeCore - Hearts"
        set metadata value "core" of {_page} to true
        set slot 0 of {_page} to a barrier named "Back"
        if {lc::settings::allow_heart_loss} is true:
            set slot 10 of {_page} to lime wool named "Disable LifeSteal" with lore "&2Hearts can be lost!"
        else:
            set slot 10 of {_page} to red wool named "Enable LifeSteal" with lore "&cHearts can not be lost!"
        set slot 12 of {_page} to lime wool named "&2Chance to lose a heart (0-100)" with lore "&2Click to change"
        set slot 14 of {_page} to lime wool named "&2Heart loss count (Heart loss on death)" with lore "&2Click to change"
        open {_page} to {_player}


on inventory click:
    if name of event-inventory is "LifeCore - Home":
        cancel event
        if event-slot is 0:
            close the player's inventory
        else if event-slot is 10:
            openCoreSettings(1, player)
    else if name of event-inventory is "LifeCore - Hearts":
        cancel event
        if event-slot is 10:
            set {_new} to toggleVar({lc::settings::allow_heart_loss})
            set {lc::settings::allow_heart_loss} to {_new}
            if {lc::settings::allow_heart_loss} is true:
                broadcast "&2Heart loss is now &e&lENABLED!"
            else:
                broadcast "&2Heart loss is now &e&lDISABLED!"
            openCoreSettings(1, player)
        else if event-slot is 12:
            set {lc::%uuid of player%::waitingfor} to "heart_steal_chance"
            close the player's inventory
            send "&eEnter a %% (0-100)"
        else if event-slot is 14:
            set {lc::%uuid of player%::waitingfor} to "heart_steal_count"
            close the player's inventory
            send "&eEnter the number of hearts that player's will lose on death"

command /remheart <player> [<number>]:
    permission: lc.hearts.remheart
    aliases: removeheart, loseheart
    description: Remove hearts from a player
    trigger:
        set {_p} to arg-1
        set {_count} to arg-2

        if {_count} isn't set:
            set {_count} to 1
        
        set {_prev} to max health of {_p}
        set {_new} to {_prev} - {_count}
        set max health of {_p} to {_new}


command /addheart <player> [<number>]:
    permission: lc.hearts.addheart
    aliases: addheart
    description: Add hearts to a player
    trigger:
        set {_p} to arg-1
        set {_count} to arg-2

        if {_count} isn't set:
            set {_count} to 1
        
        set {_prev} to max health of {_p}
        set {_new} to {_prev} + {_count}
        set max health of {_p} to {_new}

on death of player:
    set {_attacker} to attacker
    set {_victim} to victim
    if {lc::settings::allow_heart_loss} is true:
        execute CONSOLE command "remheart %{_victim}% %{lc::settings::heart_steal_count}%"
        if {lc::settings::lose_on} is "player":
            if {_attacker} is a player:
                set {_num} to a random integer between 0 and 100
                if {_num} <= {lc::settings::heart_steal_chance}:
                    if {lc::settings::loss_type} is "drop":
                        loop {lc::settings::heart_steal_count} times:
                            drop a nether star named "&cHeart" with lore "&1Tier 1"
                            set metadata value "tier" of last dropped item to 1
                else:
                    send "&cYou killed %{_victim}% but didn't gain a heart!" to {_attacker}
                    send "&2%{_attacker}% killed you but you didn't lose any hearts!" to {_victim}
        else:
            set {_num} to a random integer between 0 and 100
            if {_num} <= {lc::settings::heart_steal_chance}:
                if {lc::settings::loss_type} is "drop":
                    loop {lc::settings::heart_steal_count} times:
                        drop a nether star named "&cHeart" with lore "&1Tier 1"
                        set metadata value "tier" of last dropped item to 1
                    execute CONSOLE command "remheart %{_victim}% %{lc::settings::heart_steal_count}%"
            else:
                send "&cYou killed %{_victim}% but didn't gain a heart!" to {_attacker}
                send "&2%{_attacker}% killed you but you didn't lose any hearts!" to {_victim}
    else:
        send "&cYou killed %{_victim}% but didn't gain a heart!" to {_attacker}
        send "&2%{_attacker}% killed you but you didn't lose any hearts!" to {_victim}
    if {server::deathcore::plugins::*} contains "EasyEco":
        execute CONSOLE command "addcurrency kills 1 %{_attacker}%"
        execute CONSOLE command "addcurrency cash 100 %{_attacker}%"
    else:



on right click:
    if player's tool is nether star:
        if name of player's tool is "&cHeart":
            cancel event
            set {_lore::*} to lore of player's tool
            if {_lore::1} is "&1Tier 1":
                set {_tier} to 1
            else if {_lore::1} is "&5Tier 2":
                set {_tier} to 2
            else:
                stop
            execute console command "addheart %player% %{_tier}%"
            remove 1 nether star named "&cHeart" from player's inventory

on first join:
    send "&2&lWelcome to %{lc::server::name}%"
    send "&2Be sure to type &l/help&2 to view a list of commands!"


on join:
    set {lc::%uuid of player%::waitingfor} to "none"
on chat:
    cancel event
    if {lc::%uuid of player%::waitingfor} isn't "none":
        set {_type} to {lc::%uuid of player%::waitingfor}
        if {_type} is "heart_steal_chance":
            set {_msg} to message parsed as number
            if {_msg} >= 0:
                if {_msg} <= 100:
                    set {lc::settings::heart_steal_chance} to {_msg}
                    send "&aHeart steal chance set to %{_msg}%"
                    set {lc::%uuid of player%::waitingfor} to "none"
                else:
                    send "&cPlease enter a number between 0 and 100."
            else:
                send "&cPlease enter a number between 0 and 100."
            
            
        else if {_type} is "heart_steal_count":
            set {_msg} to message parsed as number
            if {_msg} is set:
                set {lc::settings::heart_steal_count} to {_msg}
                send "&aHearts lossed on death set to %{_msg}%"
                set {lc::%uuid of player%::waitingfor} to "none"
                broadcast "&cYou will now lose &e%{lc::settings::heart_steal_count}% hearts&c on death!"
    else:
        broadcast "%player's prefix%&4%player's display name%&f%player's suffix%: %message%"

command /withdraw [<number>]:
    description: Withdraw a heart
    usage: /withdraw [count]
    trigger:
        set {_count} to arg-1
        if {_count} isn't set:
            set {_count} to 1
        set {_max} to max health of player
        if {_count} >= {_max}:
            send "&cYou do not have enough hearts!"
            stop
        execute CONSOLE command "remheart %player% %{_count}%"
        loop {_count} times:
            set {_item} to a nether star named "&cHeart" with lore "&1Tier 1"
            set metadata value "tier" of {_item} to 1
            give {_item} to player

command /forcekill <player> <player>:
    usage: /forcekill <attacker> <victim>
    permission: lc.admin.forcekill
    description: Force a player to kill another player
    trigger:
        set {_attacker} to arg-1
        set {_victim} to arg-2

        kill {_victim}
        if {lc::settings::allow_heart_loss} is true:
            if {lc::settings::lose_on} is "player":
                if {_attacker} is a player:
                    set {_num} to a random integer between 0 and 100
                    if {_num} <= {lc::settings::heart_steal_chance}:
                        if {lc::settings::loss_type} is "drop":
                            loop {lc::settings::heart_steal_count} times:
                                drop a nether star named "&cHeart" with lore "&1Tier 1"
                                set metadata value "tier" of last dropped item to 1
                            execute CONSOLE command "remheart %{_victim}% %{lc::settings::heart_steal_count}%"
                        else:
                            execute CONSOLE command "addheart %{_attacker}% %{lc::settings::heart_steal_count}%"
                            execute CONSOLE command "remheart %{_victim}% %{lc::settings::heart_steal_count}%"
                    else:
                        send "&cYou killed %{_victim}% but didn't gain a heart!" to {_attacker}
                        send "&2%{_attacker}% killed you but you didn't lose any hearts!" to {_victim}

every 5 seconds:
    loop all players:
        if max health of loop-value < 1:
            broadcast "&7[&4LifeSteal&7] %loop-value% has been eliminated!"
            ban loop-value due to "You lost all of your health!" for 7 days
            kick loop-value due to "You lost all of your health!"
            set loop-value's max health to 5
                        
command /setserver <text>:
    description: Set the server's name
    permission: lc.server.setname
    usage: /setserver <name>
    trigger:
        set {_name} to arg-1
        set {lc::server::name} to {_name}
        send "&2Changed server name to &e%{lc::server::name}%"


command /lchelp:
    description: View LifeCore commands
    aliases: helplc, lifecorehelp, lifestealhelp
    trigger:
        send "&8&m-----------------------------"
        send "&2&lLifeCore Help"
        send "&7Server: &a%{lc::server::name}%"
        send "&8&m-----------------------------"

        send "&bGeneral"
        send "&e/withdraw [amount] &7- Withdraw hearts into items"
        send "&e/sethome &7- Set your home"
        send "&e/home &7- Teleport to your home (5s, don't move!)"
        send ""

        if {lc::settings::allow_clans} is true:
            send "&bClans"
            send "&e/clan create <name> &7- Create a clan"
            send "&e/clan join <name> &7- Join a clan"
            send "&e/clan leave &7- Leave your clan"
            send "&e/clan manage &7- Manage your clan"
            send "&e/clan transfer <player> &7- Transfer ownership"
            send "&e/clan invite <player> &7- Invite a player"
            send "&e/clan applications &7- View applications"
            send "&e/clan approve <player> &7- Approve an application"
            send "&e/clan reject <player> &7- Reject an application"
            send "&e/clan list &7- List clans"
            send "&e/clan chat <message> &7- Clan chat"
            send ""

        send "&bTeleport / TPA"
        send "&e/tpa <player> &7- Request to teleport to a player (expires 30s)"
        send "&e/tpahere <player> &7- Request a player to teleport to you (expires 30s)"
        send "&e/tpaccept &7- Accept a pending teleport request (5s delay)"
        send "&e/tpdeny &7- Deny a pending teleport request"
        send ""

        if player has permission "lc.hearts.addheart":
            send "&bHeart Management"
            if player has permission "lc.hearts.addheart":
                send "&e/addheart <player> [amount] &7- Add hearts"
            if player has permission "lc.hearts.remheart":
                send "&e/remheart <player> [amount] &7- Remove hearts"
            send ""
        else if player has permission "lc.hearts.remheart":
            send "&bHeart Management"
            if player has permission "lc.hearts.addheart":
                send "&e/addheart <player> [amount] &7- Add hearts"
            if player has permission "lc.hearts.remheart":
                send "&e/remheart <player> [amount] &7- Remove hearts"

                send ""


        send "&bAdmin"
        if player has permission "lc.panel":
            send "&e/lc &7- Open LifeCore settings panel"
        if player has permission "lc.admin.forcekill":
            send "&e/forcekill <attacker> <victim> &7- Force a kill"
        if player has permission "lc.server.setname":
            send "&e/setserver <name> &7- Set server name"

        send "&8&m-----------------------------"

function getClan(p: player) :: string:
    set {_clan} to {lc::%uuid of {_p}%::clan}
    if {_clan} is not set:
        return ""
    if {lc::clans::%{_clan}%::owner} is uuid of {_p}:
        return "owner:%{_clan}%"
    else:
        return "member:%{_clan}%"

function manageClan(page: number, player: player, item: string = "none"):
    set {_clanName} to {lc::%uuid of {_player}%::clan}
    if {_clanName} is not set:
        send "&cYou are not in a clan!" to {_player}
        stop
    if {lc::clans::%{_clanName}%::owner} is not uuid of {_player}:
        send "&cOnly the clan owner can manage the clan!" to {_player}
        stop

    if {_page} is 0:
        set {_inv} to a new chest inventory with 6 rows named "Clan Management - %{_clanName}%"
        set metadata value "clan" of {_inv} to {_clanName}
        set slot 0 of {_inv} to barrier named "Close"
        set slot 10 of {_inv} to {_player}'s skull named "Members" with lore "Click to manage members"
        set slot 12 of {_inv} to diamond named "Visibility" with lore "Click to change visibility"
        set {_apps} to size of {lc::clans::%{_clanName}%::applications::*}
        if {_apps} is 0:
            set {_appsText} to "No applications"
        else:
            set {_appsText} to "%{_apps}% pending"
        set slot 14 of {_inv} to paper named "Applications" with lore {_appsText}
        open {_inv} to {_player}

    else if {_page} is 1:
        set {_inv} to a new chest inventory with 6 rows named "Member Management - %{_clanName}%"
        set metadata value "clan" of {_inv} to {_clanName}
        set slot 0 of {_inv} to barrier named "Back"
        set {_slot} to 9
        loop {lc::clans::%{_clanName}%::members::*}:
            if {_slot} > 53:
                stop
            set {_uuid} to loop-value
            set {_member} to {_uuid} parsed as offlineplayer
            set slot {_slot} of {_inv} to skull of {_member} named "&a%name of {_member}%"
            add 1 to {_slot}
        open {_inv} to {_player}

    else if {_page} is 2:
        set {_inv} to a new chest inventory with 3 rows named "Clan Visibility - %{_clanName}%"
        set metadata value "clan" of {_inv} to {_clanName}
        set slot 0 of {_inv} to barrier named "Back"
        set {_vis} to {lc::clans::%{_clanName}%::visibility}
        if {_vis} is "public":
            set slot 4 of {_inv} to book named "Current: Public" with lore "Anyone can join"
        else if {_vis} is "application":
            set slot 4 of {_inv} to book named "Current: Applications" with lore "Players must apply"
        else:
            set slot 4 of {_inv} to book named "Current: Private" with lore "Invites only"
        set slot 10 of {_inv} to paper named "Set Private" with lore "Invites only"
        set slot 13 of {_inv} to paper named "Set Applications" with lore "Players apply"
        set slot 16 of {_inv} to paper named "Set Public" with lore "Anyone can join"
        open {_inv} to {_player}

    else if {_page} is 3:
        if {_item} is "none":
            send "&cNo member selected!" to {_player}
            stop
        set {_inv} to a new chest inventory with 3 rows named "Manage Member: %{_item}%"
        set slot 0 of {_inv} to barrier named "Back"
        set slot 10 of {_inv} to red wool named "Kick Member" with lore "Remove this member from the clan"
        set slot 12 of {_inv} to {_item}'s skull named "%{_item}%"
        set slot 14 of {_inv} to paper named "Message Member" with lore "Send a message (use /msg)"
        open {_inv} to {_player}

    else if {_page} is 4:
        set {_inv} to a new chest inventory with 6 rows named "Applications - %{_clanName}%"
        set metadata value "clan" of {_inv} to {_clanName}
        set slot 0 of {_inv} to barrier named "Back"
        set {_slot} to 9
        loop {lc::clans::%{_clanName}%::applications::*}:
            if {_slot} > 53:
                stop
            set {_uuid} to loop-value
            set {_app} to {_uuid} parsed as offlineplayer
            set slot {_slot} of {_inv} to skull of {_app} named "&e%name of {_app}%"
            add 1 to {_slot}
        open {_inv} to {_player}

    else if {_page} is 5:
        if {_item} is "none":
            send "&cNo application selected!" to {_player}
            stop
        set {_inv} to a new chest inventory with 3 rows named "Manage Application: %{_item}%"
        set slot 0 of {_inv} to barrier named "Back"
        set slot 10 of {_inv} to green wool named "Approve" with lore "Approve this application"
        set slot 12 of {_inv} to {_item}'s skull named "%{_item}%"
        set slot 14 of {_inv} to red wool named "Reject" with lore "Reject this application"
        open {_inv} to {_player}

on inventory click:
    # Main Clan Management
    if name of event-inventory starts with "Clan Management":
        cancel event
        if {_clan} is not set:
            set {_clan} to {lc::%uuid of player%::clan}
        if event-slot is 0:
            close player's inventory
        else if event-slot is 10:
            manageClan(1, player)
        else if event-slot is 12:
            manageClan(2, player)
        else if event-slot is 14:
            manageClan(4, player)

    # Member Management list
    else if name of event-inventory starts with "Member Management":
        cancel event
        if event-slot is 0:
            manageClan(0, player)
            stop
        if event-item is a player skull:
            manageClan(3, player, name of event-item)

    # Manage member
    else if name of event-inventory starts with "Manage Member:":
        cancel event
        if event-slot is 0:
            manageClan(1, player)
            stop
        if event-slot is 10:
            set {_name} to name of event-inventory
            replace all "Manage Member: " in {_name} with ""
            set {_name} to stripColors({_name})
            send "&eSelected player: %{_name}%" # debug
            set {_p} to {_name} parsed as offlineplayer
            if {_p} is not set:
                send "&cInvalid player!" to player
                stop
            if {lc::clans::%{lc::%uuid of player%::clan}%::owner} is uuid of {_p}:
                send "&cYou cannot remove the clan owner!" to player
                stop
            set {_clan} to {lc::%uuid of player%::clan}
            remove uuid of {_p} from {lc::clans::%{_clan}%::members::*}
            delete {lc::%uuid of {_p}%::clan}
            send "&2Removed &e%name of {_p}% &2from the clan!" to player
            close player's inventory



    # Clan Visibility
    else if name of event-inventory starts with "Clan Visibility":
        set {_clan} to {lc::%uuid of player%::clan}
        cancel event
        if event-slot is 0:
            manageClan(0, player)
            stop
        if event-slot is 10:
            set {lc::clans::%{_clan}%::visibility} to "private"
            manageClan(2, player)
        else if event-slot is 13:
            set {lc::clans::%{_clan}%::visibility} to "application"
            manageClan(2, player)
        else if event-slot is 16:
            set {lc::clans::%{_clan}%::visibility} to "public"
            manageClan(2, player)

    # Applications list
    else if name of event-inventory starts with "Applications":
        cancel event
        if event-slot is 0:
            manageClan(0, player)
            stop
        if event-item is a player skull:
            manageClan(5, player, name of event-item)

    # Manage Application
    else if name of event-inventory starts with "Manage Application:":
        cancel event
        if event-slot is 0:
            manageClan(4, player)
            stop
        set {_target} to name of event-item parsed as offlineplayer
        set {_clan} to {lc::%uuid of player%::clan}
        if event-slot is 10: # Approve
            make player execute command "clan approve %{_target}%"
            manageClan(4, player)
        else if event-slot is 14: # Reject
            make player execute command "clan reject %{_target}%"
            manageClan(4, player)
every 3 seconds:
    loop all players:
        set {_clan} to {lc::%uuid of loop-player%::clan}
        set prefix of loop-value to "&7[&e%{_clan}%&7] "


command /clan <text> [<text>]:
    description: Clan management
    usage: /clan <create|join|leave|manage|transfer|list|delete|chat|invite|applications|approve|reject> [name|player|message]
    trigger:
        set {_sub} to arg-1
        set {_arg} to arg-2

        if {_sub} is "create":
            if {_arg} is not set:
                send "&cUsage: /clan create <name>"
                stop
            if {lc::%uuid of player%::clan} is set:
                send "&cYou are already in a clan!"
                stop
            if {lc::clans::%{_arg}%::owner} is set:
                send "&cThat clan already exists!"
                stop
            set {lc::clans::%{_arg}%} to {_arg}
            set {lc::clans::%{_arg}%::owner} to uuid of player
            add uuid of player to {lc::clans::%{_arg}%::members::*}
            set {lc::%uuid of player%::clan} to {_arg}
            set {lc::clans::%{_arg}%::visibility} to "public"
            set {lc::clans::%{_arg}%::prefix} to "&7[&e%{_arg}%&7] "
            send "&aClan &e%{_arg}% &acreated!"

        else if {_sub} is "join":
            if {_arg} is not set:
                send "&cUsage: /clan join <name>"
                stop
            if {lc::%uuid of player%::clan} is set:
                send "&cYou are already in a clan!"
                stop
            if {lc::clans::%{_arg}%::owner} is not set:
                send "&cThat clan does not exist!"
                stop
            set {_vis} to {lc::clans::%{_arg}%::visibility}
            
            # Check invites
            if {lc::clans::%{_arg}%::invites::*} contains uuid of player:
                remove uuid of player from {lc::clans::%{_arg}%::invites::*}
                add uuid of player to {lc::clans::%{_arg}%::members::*}
                set {lc::%uuid of player%::clan} to {_arg}
                send "&aYou joined clan &e%{_arg}% &athanks to an invite!"
                loop {lc::clans::%{_arg}%::members::*}:
                    set {_m} to loop-value parsed as player
                    if {_m} is online:
                        send "&e%player% &ajoined the clan!" to {_m}
                stop

            # Private check
            if {_vis} is "private":
                send "&cThat clan is private and you were not invited!"
                stop

            # Application check
            if {_vis} is "application":
                if {lc::clans::%{_arg}%::applications::*} contains uuid of player:
                    send "&cYou have already applied to &e%{_arg}%&c."
                    stop
                add uuid of player to {lc::clans::%{_arg}%::applications::*}
                set {_owner} to {lc::clans::%{_arg}%::owner}
                set {_owner} to {_owner} parsed as player
                send "&e%player% &ahas applied to join your clan." to {_owner}
                send "&aYou applied to join &e%{_arg}%&a. Wait for approval."
                stop

            # Public join
            add uuid of player to {lc::clans::%{_arg}%::members::*}
            set {lc::%uuid of player%::clan} to {_arg}
            send "&aYou joined clan &e%{_arg}%"
            loop {lc::clans::%{_arg}%::members::*}:
                set {_m} to loop-value parsed as player
                if {_m} is online:
                    send "&e%player% &ajoined the clan!" to {_m}


        else if {_sub} is "leave":
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            if {lc::clans::%{_clan}%::owner} is uuid of player:
                send "&cYou must transfer ownership before leaving!"
                stop
            remove uuid of player from {lc::clans::%{_clan}%::members::*}
            delete {lc::%uuid of player%::clan}
            send "&cYou left clan &e%{_clan}%"
            loop {lc::clans::%{_clan}%::members::*}:
                set {_m} to loop-value parsed as player
                if {_m} is online:
                    send "&e%player% &cleft the clan!" to {_m}

        else if {_sub} is "manage":
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            if {lc::clans::%{_clan}%::owner} is not uuid of player:
                send "&cOnly the clan owner can manage the clan!"
                stop
            manageClan(0, player)

        else if {_sub} is "transfer":
            if {_arg} is not set:
                send "&cUsage: /clan transfer <player>"
                stop
            set {_target} to {_arg} parsed as offline player
            if {_target} is not set:
                send "&cThat player does not exist!"
                stop
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            if {lc::clans::%{_clan}%::owner} is not uuid of player:
                send "&cOnly the owner can transfer ownership!"
                stop
            if {lc::%uuid of {_target}%::clan} is not {_clan}:
                send "&cThat player is not in your clan!"
                stop
            set {lc::clans::%{_clan}%::owner} to uuid of {_target}
            send "&aOwnership transferred to &e%name of {_target}%"
            if {_target} is online:
                send "&aYou are now the owner of clan &e%{_clan}%" to {_target}

        else if {_sub} is "invite":
            if {_arg} is not set:
                send "&cUsage: /clan invite <player>"
                stop
            set {_target} to {_arg} parsed as offline player
            if {_target} is not set:
                send "&cPlayer not found!"
                stop
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            if {lc::clans::%{_clan}%::owner} is not uuid of player:
                send "&cOnly the clan owner can invite players!"
                stop
            if {lc::%uuid of {_target}%::clan} is set:
                send "&cThat player is already in a clan!"
                stop
            add uuid of {_target} to {lc::clans::%{_clan}%::invites::*}
            send "&aYou invited &e%name of {_target}% &ato your clan!"
            if {_target} is online:
                send "&aYou have been invited to join clan &e%{_clan}%&a. Use &7/clan join %{_clan}%&a to accept." to {_target}

        else if {_sub} is "applications":
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            if {lc::clans::%{_clan}%::owner} is not uuid of player:
                send "&cOnly the clan owner can view applications!"
                stop
            if size of {lc::clans::%{_clan}%::applications::*} is 0:
                send "&cNo pending applications."
                stop
            send "&2Applications for &e%{_clan}%&2:"
            set {_i} to 1
            loop {lc::clans::%{_clan}%::applications::*}:
                set {_p} to loop-value parsed as offline player
                send "&e%{_i}% &7- &a%name of {_p}% &7- &e/clan approve %name of {_p}% &e/clan reject %name of {_p}%"
                add 1 to {_i}

        else if {_sub} is "approve":
            if {_arg} is not set:
                send "&cUsage: /clan approve <player>"
                stop
            set {_target} to {_arg} parsed as offline player
            if {_target} is not set:
                send "&cPlayer not found!"
                stop
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            if {lc::clans::%{_clan}%::owner} is not uuid of player:
                send "&cOnly the clan owner can approve applications!"
                stop
            if {lc::clans::%{_clan}%::applications::*} doesn't contain uuid of {_target}:
                send "&cThis player has not applied!"
                stop
            remove uuid of {_target} from {lc::clans::%{_clan}%::applications::*}
            add uuid of {_target} to {lc::clans::%{_clan}%::members::*}
            set {lc::%uuid of {_target}%::clan} to {_clan}
            send "&aApproved &e%name of {_target}% &ato join the clan!"
            if {_target} is online:
                send "&aYour application to join clan &e%{_clan}% &ahas been approved!" to {_target}

        else if {_sub} is "reject":
            if {_arg} is not set:
                send "&cUsage: /clan reject <player>"
                stop
            set {_target} to {_arg} parsed as offline player
            if {_target} is not set:
                send "&cPlayer not found!"
                stop
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            if {lc::clans::%{_clan}%::owner} is not uuid of player:
                send "&cOnly the clan owner can reject applications!"
                stop
            if {lc::clans::%{_clan}%::applications::*} doesn't contain uuid of {_target}:
                send "&cThis player has not applied!"
                stop
            remove uuid of {_target} from {lc::clans::%{_clan}%::applications::*}
            send "&cRejected &e%name of {_target}% &7from joining the clan."
            if {_target} is online:
                send "&cYour application to join clan &e%{_clan}% &chas been rejected!" to {_target}

        else if {_sub} is "list":
            send "&2Clans&m------------------"
            set {_i} to 1
            loop {lc::clans::*}:
                set {_clan} to loop-value
                if {lc::clans::%{_clan}%::visibility} is "private":
                    continue
                send "&e%{_i}% &7- &a%{_clan}% &7- %{lc::clans::%{_clan}%::visibility}%"
                add 1 to {_i}
            if {_i} is 1:
                send "&cNo public clans found."
            send "&2&m-----------------------"

        else if {_sub} is "delete":
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            if {lc::clans::%{_clan}%::owner} is not uuid of player:
                send "&cOnly the clan owner can delete the clan!"
                stop
            loop {lc::clans::%{_clan}%::members::*}:
                set {_m} to loop-value parsed as player
                if {_m} is online:
                    send "&cClan &e%{_clan}% &chas been deleted by the owner!" to {_m}
            loop {lc::clans::%{_clan}%::members::*}:
                delete {lc::%loop-value%::clan}
            delete {lc::clans::%{_clan}%::*}
            delete {lc::clans::%{_clan}%}
            send "&aYou have successfully deleted the clan &e%{_clan}%!"

        else if {_sub} is "chat":
            if {_arg} is not set:
                send "&cUsage /clan chat <message>"
                stop
            set {_clan} to {lc::%uuid of player%::clan}
            if {_clan} is not set:
                send "&cYou are not in a clan!"
                stop
            loop {lc::clans::%{_clan}%::members::*}:
                set {_member} to loop-value parsed as player
                if {_member} is online:
                    send "&7[&bCLAN&7] &c%player's display name%:&f %{_arg}%" to {_member}

        else:
            send "&cUsage:"
            send "&7/clan create <name>"
            send "&7/clan join <name>"
            send "&7/clan leave"
            send "&7/clan manage"
            send "&7/clan transfer <player>"
            send "&7/clan invite <player>"
            send "&7/clan applications"
            send "&7/clan approve <player>"
            send "&7/clan reject <player>"
            send "&7/clan list"
            send "&7/clan delete"
            send "&7/clan chat <message>"

command /tpa <player>:
    description: Request to teleport to a player
    trigger:
        set {_target} to arg-1
        if {_target} is not set:
            send "&cUsage: /tpa <player>"
            stop
        if {_target} is player:
            send "&cYou can't tpa to yourself."
            stop
        if {_target} is not online:
            send "&cThat player is not online."
            stop
        set {_tuid} to uuid of {_target}
        if {lc::tpa::%{_tuid}%::from} is set:
            send "&cThat player already has a pending tp request."
            stop
        set {lc::tpa::%{_tuid}%::from} to uuid of player
        set {lc::tpa::%{_tuid}%::type} to "tpa"
        set {lc::tpa::%{_tuid}%::name} to player's display name
        send "&aTeleport request sent to &e%name of {_target}%&a. It will expire in 30s."
        send "&e%player% &awants to teleport to you. Type &e/tpaccept &ato accept or &e/tpdeny &ato deny. (30s)" to {_target}

        wait 30 seconds
        if {lc::tpa::%{_tuid}%::from} is uuid of player:
            if {lc::tpa::%{_tuid}%::type} is "tpa":
                delete {lc::tpa::%{_tuid}%::*}
                if {_target} is online:
                    send "&cTeleport request from &e%{lc::tpa::%{_tuid}%::name}%&c has expired." to {_target}
                if player is online:
                    send "&cYour teleport request to &e%name of {_target}%&c has expired."

command /tpahere <player>:
    description: Request a player to teleport to you
    trigger:
        set {_target} to arg-1
        if {_target} is not set:
            send "&cUsage: /tpahere <player>"
            stop
        if {_target} is player:
            send "&cYou can't tpahere yourself."
            stop
        if {_target} is not online:
            send "&cThat player is not online."
            stop
        set {_tuid} to uuid of {_target}
        if {lc::tpa::%{_tuid}%::from} is set:
            send "&cThat player already has a pending tp request."
            stop
        set {lc::tpa::%{_tuid}%::from} to uuid of player
        set {lc::tpa::%{_tuid}%::type} to "tpahere"
        set {lc::tpa::%{_tuid}%::name} to player's display name
        send "&aTpahere request sent to &e%name of {_target}%&a. It will expire in 30s."
        send "&e%player% &awants you to teleport to them. Type &e/tpaccept &ato accept or &e/tpdeny &ato deny. (30s)" to {_target}

        wait 30 seconds
        if {lc::tpa::%{_tuid}%::from} is uuid of player:
            if {lc::tpa::%{_tuid}%::type} is "tpahere":
                delete {lc::tpa::%{_tuid}%::*}
                if {_target} is online:
                    send "&cTpahere request from &e%{lc::tpa::%{_tuid}%::name}%&c has expired." to {_target}
                if player is online:
                    send "&cYour tpahere request to &e%name of {_target}%&c has expired."

command /tpaccept:
    description: Accept a pending tp request
    trigger:
        set {_tuid} to uuid of player
        if {lc::tpa::%{_tuid}%::from} is not set:
            send "&cYou have no pending teleport requests."
            stop
        set {_fromUUID} to {lc::tpa::%{_tuid}%::from}
        set {_type} to {lc::tpa::%{_tuid}%::type}
        set {_from} to {_fromUUID} parsed as player
        set {_fromName} to {lc::tpa::%{_tuid}%::name}
        if {_from} is not set:
            send "&cThe requester is no longer online. Request cancelled."
            delete {lc::tpa::%{_tuid}%::*}
            stop

        if {_type} is "tpa":
            send "&aYou accepted &e%{_fromName}%&a's teleport request. Teleporting them in 5s. Don't move!" to player
            send "&a%name of player% &ahas accepted your teleport request. Teleporting in 5s. Don't move!" to {_from}
            set {server::%{_fromUUID}%::teleporting} to true
            loop 5 times:
                wait 1 second
                if {server::%{_fromUUID}%::teleporting} is not true:
                    send "&cTeleport cancelled." to {_from}
                    send "&cTeleport cancelled." to player
                    delete {lc::tpa::%{_tuid}%::*}
                    delete {server::%{_fromUUID}%::teleporting}
                    stop
                else if {_from} is not online:
                    send "&cTeleport cancelled." to {_from}
                    send "&cTeleport cancelled." to player
                    delete {lc::tpa::%{_tuid}%::*}
                    delete {server::%{_fromUUID}%::teleporting}
                    stop
                else if player is not online:
                    send "&cTeleport cancelled." to {_from}
                    send "&cTeleport cancelled." to player
                    delete {lc::tpa::%{_tuid}%::*}
                    delete {server::%{_fromUUID}%::teleporting}
                    stop
            teleport {_from} to player
            send "&aTeleported &e%name of {_from}% &ato &e%name of player%&a." to server
            delete {lc::tpa::%{_tuid}%::*}
            delete {server::%{_fromUUID}%::teleporting}

        else if {_type} is "tpahere":
            send "&aYou accepted &e%{_fromName}%&a's tpahere request. Teleporting you in 5s. Don't move!" to player
            send "&a%name of player% &ahas accepted your tpahere request. Teleporting them in 5s." to {_from}
            set {server::%{_tuid}%::teleporting} to true
            loop 5 times:
                wait 1 second
                if {server::%{_tuid}%::teleporting} is not true:
                    send "&cTeleport cancelled." to {_from}
                    send "&cTeleport cancelled." to player
                    delete {lc::tpa::%{_tuid}%::*}
                    delete {server::%{_tuid}%::teleporting}
                    stop
                else if {_from} is not online:
                    send "&cTeleport cancelled." to {_from}
                    send "&cTeleport cancelled." to player
                    delete {lc::tpa::%{_tuid}%::*}
                    delete {server::%{_tuid}%::teleporting}
                    stop
                else if player is not online:
                    send "&cTeleport cancelled." to {_from}
                    send "&cTeleport cancelled." to player
                    delete {lc::tpa::%{_tuid}%::*}
                    delete {server::%{_tuid}%::teleporting}
                    stop
            teleport player to {_from}
            send "&aTeleported &e%name of player% &ato &e%name of {_from}%&a." to server
            delete {lc::tpa::%{_tuid}%::*}
            delete {server::%{_tuid}%::teleporting}

command /tpdeny:
    description: Deny a pending tp request
    trigger:
        set {_tuid} to uuid of player
        if {lc::tpa::%{_tuid}%::from} is not set:
            send "&cYou have no pending teleport requests."
            stop
        set {_fromUUID} to {lc::tpa::%{_tuid}%::from}
        set {_fromName} to {lc::tpa::%{_tuid}%::name}
        set {_from} to {_fromUUID} parsed as player
        if {_from} is set:
            send "&c%player% denied your teleport request." to {_from}
        send "&cYou denied the teleport request from &e%{_fromName}%&c."
        delete {lc::tpa::%{_tuid}%::*}


on command "/help":
    if player doesn't have permission "op":
        cancel event
        make player execute command "lchelp"

command /sethome:
    description: Set your home
    trigger:
        set {server::%uuid of player%::home} to player's location
        send "&2Your home has been set."

command /home:
    description: Teleport home
    trigger:
        if {server::%uuid of player%::home} isn't set:
            send "&cHome is not set!"
            send "&cSet it with &7/sethome"
            stop
        send "&e&lDON'T MOVE! &r&cTeleporting in 5 seconds..."
        set {server::%uuid of player%::teleporting} to true
        loop 5 times:
            wait 1 second
            if {server::%uuid of player%::teleporting} is not true:
                send "&cTeleport cancelled because you moved!"
                stop
        # final checks
        if {server::%uuid of player%::teleporting} is true:
            teleport player to {server::%uuid of player%::home}
            send "&aTeleported you home."
        delete {server::%uuid of player%::teleporting}

on player move:
    if {server::%uuid of player%::teleporting} is true:
        delete {server::%uuid of player%::teleporting}
        send "&cTeleport cancelled because you moved!"


on damage of player:
    if {lc::settings::allow_friendlyfire} isn't true:
        set {_clan1} to {lc::%uuid of attacker%::clan}
        set {_clan2} to {lc::%uuid of victim%::clan}

        if {_clan1} is set:
            if {_clan2} is set:
                if {_clan1} is {_clan2}:
                    cancel event
                    send "&cYou cannot attack clan members!" to attacker


